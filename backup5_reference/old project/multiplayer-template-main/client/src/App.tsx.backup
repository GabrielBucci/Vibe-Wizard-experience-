import React, { useState, useEffect, useCallback, useRef } from 'react';
import './App.css';
import { GameScene } from './components/GameScene';
import { PlayerUI } from './components/PlayerUI';
import { DebugPanel } from './components/DebugPanel';
import { JoinGameDialog } from './components/JoinGameDialog';
import * as moduleBindings from './generated';
import * as THREE from 'three';

// Re-export types we need
type Identity = moduleBindings.Identity;
type PlayerData = moduleBindings.PlayerData;
type InputState = moduleBindings.InputState;

// Key mapping for WASD and sprint
const keyMap: { [key: string]: keyof InputState } = {
  KeyW: 'forward',
  KeyS: 'backward',
  KeyA: 'left',
  KeyD: 'right',
  ShiftLeft: 'sprint',
  Space: 'jump',
};

function App() {
  const [connected, setConnected] = useState(false);
  const [identity, setIdentity] = useState<Identity | null>(null);
  const [players, setPlayers] = useState<Map<string, PlayerData>>(new Map());
  const [localPlayer, setLocalPlayer] = useState<PlayerData | null>(null);
  const [showDebugPanel, setShowDebugPanel] = useState(false);
  const [isPointerLocked, setIsPointerLocked] = useState(false);
  const [username, setUsername] = useState('');
  const [characterClass, setCharacterClass] = useState('Wizard');
  const [showJoinDialog, setShowJoinDialog] = useState(true);

  // Refs for managing game state
  const connRef = useRef<moduleBindings.DbConnection | null>(null);
  const playerRotationRef = useRef(new THREE.Euler(0, 0, 0, 'YXZ'));
  const currentInputRef = useRef<InputState>({
    forward: false,
    backward: false,
    left: false,
    right: false,
    sprint: false,
    jump: false,
    attack: false,
    sequence: 0
  });
  const lastSentInputState = useRef<InputState>({ ...currentInputRef.current });
  const frameCount = useRef(0);

  // Animation determination based on input state
  const determineAnimation = useCallback((input: InputState): string => {
    if (input.attack) return 'attack1';
    if (input.jump) return 'jump';
    
    const isMoving = input.forward || input.backward || input.left || input.right;
    if (!isMoving) return 'idle';
    
    if (input.sprint) {
      if (input.forward) return 'run-forward';
      if (input.backward) return 'run-back';
      if (input.left) return 'run-left';
      if (input.right) return 'run-right';
    } else {
      if (input.forward) return 'walk-forward';
      if (input.backward) return 'walk-back';
      if (input.left) return 'walk-left';
      if (input.right) return 'walk-right';
    }
    
    return 'idle';
  }, []);

  // Initialize connection to SpacetimeDB
  useEffect(() => {
    const initConnection = async () => {
      try {
        const conn = await moduleBindings.DbConnection.builder()
          .withIdentityCallback((identity) => {
            console.log("Identity callback called with:", identity.toHexString());
            setIdentity(identity);
          })
          .withOnConnect(() => {
            console.log("Connected to SpacetimeDB");
            setConnected(true);
          })
          .withOnDisconnect(() => {
            console.log("Disconnected from SpacetimeDB");
            setConnected(false);
          })
          .build();

        connRef.current = conn;

        // Set up subscriptions
        const sub = conn.subscriptionBuilder()
          .subscribe("SELECT * FROM player")
          .onInsert((ctx, player) => {
            console.log("Player inserted:", player);
            setPlayers(prev => {
              const next = new Map(prev);
              next.set(player.identity.toHexString(), player);
              return next;
            });
            
            // If this is our player, update localPlayer
            if (identity && player.identity.toHexString() === identity.toHexString()) {
              setLocalPlayer(player);
            }
          })
          .onUpdate((ctx, player) => {
            setPlayers(prev => {
              const next = new Map(prev);
              next.set(player.identity.toHexString(), player);
              return next;
            });
            
            // If this is our player, update localPlayer
            if (identity && player.identity.toHexString() === identity.toHexString()) {
              setLocalPlayer(player);
            }
          })
          .onDelete((ctx, player) => {
            console.log("Player deleted:", player);
            setPlayers(prev => {
              const next = new Map(prev);
              next.delete(player.identity.toHexString());
              return next;
            });
            
            // If this is our player, clear localPlayer
            if (identity && player.identity.toHexString() === identity.toHexString()) {
              setLocalPlayer(null);
            }
          })
          .onError((err) => {
            console.error("Subscription error:", err);
          });

        // Start the subscription
        sub.start();

      } catch (error) {
        console.error("Failed to connect to SpacetimeDB:", error);
      }
    };

    initConnection();

    // Cleanup function
    return () => {
      if (connRef.current) {
        connRef.current.close();
        connRef.current = null;
      }
    };
  }, []); // Empty dependency array - only run once on mount

  // Handle game join
  const handleJoinGame = useCallback(async (username: string, characterClass: string) => {
    if (!connRef.current || !identity) {
      console.error("Cannot join game: no connection or identity");
      return;
    }

    try {
      // Call the register_player reducer
      await connRef.current.reducers.registerPlayer(username, characterClass);
      setShowJoinDialog(false);
      
      // Request pointer lock after joining
      document.body.requestPointerLock();
      
    } catch (error) {
      console.error("Failed to join game:", error);
    }
  }, [identity]);

  // Game update loop
  useEffect(() => {
    let animationFrameId: number;
    
    const gameLoop = () => {
      frameCount.current++;
      
      // Update input sequence number
      currentInputRef.current.sequence = frameCount.current;
      
      // Send input state to server
      sendInput(currentInputRef.current);
      
      // Request next frame
      animationFrameId = requestAnimationFrame(gameLoop);
    };
    
    // Start the game loop
    animationFrameId = requestAnimationFrame(gameLoop);
    
    // Cleanup
    return () => {
      if (animationFrameId) {
        cancelAnimationFrame(animationFrameId);
      }
    };
  }, [sendInput]); // Only re-create the loop if sendInput changes

  const sendInput = useCallback((currentInputState: InputState) => {
    if (!connRef.current || !identity || !connected) return; // Check connection status too
    const currentPosition = localPlayer?.position || { x: 0, y: 0, z: 0 };
    
    // Now using the playerRotationRef for more accurate rotation tracking
    const currentRotation = {
      x: playerRotationRef.current.x,
      y: playerRotationRef.current.y,
      z: playerRotationRef.current.z
    };
    
    // Determine animation from input state
    const currentAnimation = determineAnimation(currentInputState);

    let changed = false;
    for (const key in currentInputState) {
        if (currentInputState[key as keyof InputState] !== lastSentInputState.current[key as keyof InputState]) {
            changed = true;
            break;
        }
    }

    if (changed || currentInputState.sequence !== lastSentInputState.current.sequence) {
        connRef.current.reducers.updatePlayerInput(currentInputState, currentPosition, currentRotation, currentAnimation);
        lastSentInputState.current = { ...currentInputState };
    }
  }, [identity, localPlayer, connected, determineAnimation]);

  // Add player rotation handler
  const handlePlayerRotation = useCallback((rotation: THREE.Euler) => {
    // Update our stored rotation whenever the player rotates (from mouse movements)
    playerRotationRef.current.copy(rotation);
  }, []);

  const handleKeyDown = useCallback((event: KeyboardEvent) => {
      if (event.repeat) return; 
      const action = keyMap[event.code];
      if (action) {
          if (!currentInputRef.current[action]) { 
             currentInputRef.current[action] = true;
          }
      }
  }, []);

  const handleKeyUp = useCallback((event: KeyboardEvent) => {
      const action = keyMap[event.code];
      if (action) {
          if (currentInputRef.current[action]) { 
              currentInputRef.current[action] = false;
          }
      }
  }, []);

  const handleMouseDown = useCallback((event: MouseEvent) => {
      if (event.button === 0) { 
           if (!currentInputRef.current.attack) {
               currentInputRef.current.attack = true;
           }
      }
  }, []);

  const handleMouseUp = useCallback((event: MouseEvent) => {
      if (event.button === 0) { 
           if (currentInputRef.current.attack) {
               currentInputRef.current.attack = false;
           }
      }
  }, []);

  // Add mouse move handler with pointer lock for rotation
  const handleMouseMove = useCallback((event: MouseEvent) => {
    // Only rotate if we have pointer lock
    if (document.pointerLockElement === document.body) {
      const sensitivity = 0.002;
      // Update the Euler rotation with mouse movement
      playerRotationRef.current.y -= event.movementX * sensitivity;
      
      // Clamp vertical rotation (looking up/down) to prevent flipping
      playerRotationRef.current.x = Math.max(
        -Math.PI / 2.5, 
        Math.min(Math.PI / 2.5, playerRotationRef.current.x - event.movementY * sensitivity)
      );
    }
  }, []);

  // --- Listener Setup/Removal Functions ---
  const handlePointerLockChange = useCallback(() => {
    setIsPointerLocked(document.pointerLockElement === document.body);
    console.log("Pointer Lock Changed: ", document.pointerLockElement === document.body);
  }, []);

  // Set up event listeners
  useEffect(() => {
    // Only add gameplay-related listeners if the join dialog is not showing
    if (!showJoinDialog) {
      window.addEventListener('keydown', handleKeyDown);
      window.addEventListener('keyup', handleKeyUp);
      window.addEventListener('mousedown', handleMouseDown);
      window.addEventListener('mouseup', handleMouseUp);
      window.addEventListener('mousemove', handleMouseMove);
      document.addEventListener('pointerlockchange', handlePointerLockChange);
      
      // Handle debug panel toggle
      const handleDebugToggle = (event: KeyboardEvent) => {
        if (event.code === 'Backquote') { // ` key
          setShowDebugPanel(prev => !prev);
        }
      };
      window.addEventListener('keydown', handleDebugToggle);
      
      return () => {
        window.removeEventListener('keydown', handleKeyDown);
        window.removeEventListener('keyup', handleKeyUp);
        window.removeEventListener('mousedown', handleMouseDown);
        window.removeEventListener('mouseup', handleMouseUp);
        window.removeEventListener('mousemove', handleMouseMove);
        document.removeEventListener('pointerlockchange', handlePointerLockChange);
        window.removeEventListener('keydown', handleDebugToggle);
      };
    }
  }, [
    handleKeyDown, 
    handleKeyUp, 
    handleMouseDown, 
    handleMouseUp,
    handleMouseMove,
    handlePointerLockChange,
    showJoinDialog
  ]);

  return (
    <div className="App">
      {/* Show join dialog if not connected */}
      {showJoinDialog && (
        <JoinGameDialog 
          onJoin={handleJoinGame}
          username={username}
          setUsername={setUsername}
          characterClass={characterClass}
          setCharacterClass={setCharacterClass}
        />
      )}
      
      {/* Main game UI */}
      {!showJoinDialog && (
        <>
          <GameScene 
            players={players}
            localPlayerIdentity={identity}
            onPlayerRotation={handlePlayerRotation}
            currentInputRef={currentInputRef}
            isDebugPanelVisible={showDebugPanel}
          />
          <PlayerUI />
          {showDebugPanel && (
            <DebugPanel 
              players={players}
              localPlayer={localPlayer}
              currentInput={currentInputRef.current}
              frameCount={frameCount.current}
            />
          )}
        </>
      )}
    </div>
  );
}

export default App; 